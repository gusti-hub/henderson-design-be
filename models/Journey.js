// models/Journey.js - Updated Model for New Journey Structure
const mongoose = require('mongoose');

const journeyStepSchema = new mongoose.Schema({
  step: {
    type: Number,
    required: true
  },
  stage: {
    type: String,
    required: true
  },
  owner: {
    type: String,
    required: true
  },
  adminDescription: {
    type: String,
    required: true
  },
  clientDescription: {
    type: String,
    default: ''
  },
  clientVisible: {
    type: Boolean,
    default: false
  },
  autoEmail: {
    type: Boolean,
    default: false
  },
  docAutoGenerated: {
    type: Boolean,
    default: false
  },
  clientActionNeeded: {
    type: Boolean,
    default: false
  },
  notes: {
    type: String,
    default: ''
  },
  
  // Status tracking
  status: {
    type: String,
    enum: ['not-started', 'in-progress', 'completed'],
    default: 'not-started'
  },
  
  // Dates
  deadlineDate: {
    type: Date,
    default: null
  },
  completedDate: {
    type: Date,
    default: null
  },
  
  // Generated documents (for steps that auto-generate)
  generatedDocuments: [{
    type: {
      type: String,
      enum: ['contract', 'proposal', 'invoice', 'agreement', 'other']
    },
    filename: String,
    data: Buffer,
    generatedAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // Tracking
  updatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

const journeySchema = new mongoose.Schema({
  clientId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    unique: true
  },
  steps: [journeyStepSchema],
  
  // Contract and payment tracking
  contractData: {
    designFeeContract: {
      amount: Number,
      downPayment: Number,
      generatedAt: Date
    },
    productionContract: {
      amount: Number,
      initialPayment: Number,
      progressPayment: Number,
      finalPayment: Number,
      generatedAt: Date
    }
  },
  
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

// Indexes
journeySchema.index({ clientId: 1 });
journeySchema.index({ 'steps.status': 1 });
journeySchema.index({ 'steps.clientActionNeeded': 1, 'steps.status': 1 });

// Virtual: Current Step (first incomplete step)
journeySchema.virtual('currentStep').get(function() {
  return this.steps.find(s => s.status !== 'completed');
});

// Virtual: Progress Percentage
journeySchema.virtual('progressPercentage').get(function() {
  const completed = this.steps.filter(s => s.status === 'completed').length;
  return Math.round((completed / this.steps.length) * 100);
});

// Method: Get pending client actions
journeySchema.methods.getPendingClientActions = function() {
  return this.steps
    .filter(s => 
      s.clientVisible && 
      s.clientActionNeeded && 
      (s.status === 'in-progress' || s.status === 'not-started')
    )
    .map(s => ({
      step: s.step,
      stage: s.stage,
      title: s.clientDescription || s.adminDescription,
      deadlineDate: s.deadlineDate,
      notes: s.notes
    }));
};

// Method: Get client-visible steps
journeySchema.methods.getClientVisibleSteps = function() {
  return this.steps.filter(s => s.clientVisible);
};

// Method: Get steps by stage
journeySchema.methods.getStepsByStage = function(stageName) {
  return this.steps.filter(s => s.stage === stageName);
};

// Method: Get all unique stages
journeySchema.methods.getAllStages = function() {
  const stages = [...new Set(this.steps.map(s => s.stage))];
  return stages;
};

// Method: Get stage progress
journeySchema.methods.getStageProgress = function(stageName) {
  const stageSteps = this.steps.filter(s => s.stage === stageName);
  const completed = stageSteps.filter(s => s.status === 'completed').length;
  return {
    total: stageSteps.length,
    completed,
    percentage: Math.round((completed / stageSteps.length) * 100)
  };
};

// Method: Check if step can be started (sequential enforcement)
journeySchema.methods.canStartStep = function(stepNumber) {
  if (stepNumber === 1) return true;
  
  const previousStep = this.steps.find(s => s.step === stepNumber - 1);
  return previousStep && previousStep.status === 'completed';
};

// Method: Get next available step
journeySchema.methods.getNextAvailableStep = function() {
  for (let i = 0; i < this.steps.length; i++) {
    if (this.steps[i].status !== 'completed') {
      return this.steps[i];
    }
  }
  return null; // All steps completed
};

// Pre-save middleware
journeySchema.pre('save', function(next) {
  this.updatedAt = new Date();
  next();
});

const Journey = mongoose.model('Journey', journeySchema);

module.exports = Journey;