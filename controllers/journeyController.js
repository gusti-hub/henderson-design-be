// controllers/journeyController.js - Simplified Journey Management
const Journey = require('../models/Journey');
const User = require('../models/User');
const sendEmail = require('../utils/sendEmail');
const { generateContractPDF, generateProposalPDF } = require('../utils/contractGenerator');
const EMAIL_TEMPLATES = require('../utils/journeyEmailTemplates');
const selectEmailTemplate = require('../utils/journeyEmailMapper');

// Import all steps from data file
const JOURNEY_STEPS = require('../data/journeySteps');

// ===== GET CLIENT JOURNEY =====
const getClientJourney = async (req, res) => {
  try {
    const { clientId } = req.params;
    
    const client = await User.findById(clientId);
    if (!client) {
      return res.status(404).json({ message: 'Client not found' });
    }

    let journey = await Journey.findOne({ clientId })
      .populate('steps.updatedBy', 'name email')
      .populate('clientId', 'name email clientCode unitNumber floorPlan');
    
    if (!journey) {
      return res.status(404).json({ message: 'Journey not found for this client' });
    }
    
    res.json(journey);
  } catch (error) {
    console.error('Error fetching journey:', error);
    res.status(500).json({ message: 'Error fetching journey', error: error.message });
  }
};

// ===== CREATE CLIENT JOURNEY =====
const createClientJourney = async (req, res) => {
  try {
    const { clientId } = req.params;
    
    const existingJourney = await Journey.findOne({ clientId });
    if (existingJourney) {
      return res.status(400).json({ 
        message: 'Journey already exists for this client',
        journeyId: existingJourney._id
      });
    }
    
    const client = await User.findById(clientId);
    if (!client) {
      return res.status(404).json({ message: 'Client not found' });
    }

    // Create journey with all steps from data file
    const journey = await Journey.create({
      clientId,
      steps: JOURNEY_STEPS.map(stepData => ({
        step: stepData.step,
        stage: stepData.stage,
        owner: stepData.owner,
        adminDescription: stepData.adminDescription,
        clientDescription: stepData.clientDescription || '',
        clientVisible: stepData.clientVisible || false,
        autoEmail: stepData.autoEmail || false,
        docAutoGenerated: stepData.docAutoGenerated || false,
        clientActionNeeded: stepData.clientActionNeeded || false,
        notes: stepData.notes || '',
        status: stepData.step === 1 ? 'in-progress' : 'not-started', // First step auto-starts
        deadlineDate: null,
        completedDate: null,
        updatedBy: req.user.id,
        updatedAt: new Date()
      }))
    });
    
    await journey.populate('clientId', 'name email clientCode unitNumber');
    
    res.status(201).json({
      message: `Journey created successfully with ${JOURNEY_STEPS.length} steps`,
      journey
    });
  } catch (error) {
    console.error('Error creating journey:', error);
    res.status(500).json({ message: 'Error creating journey', error: error.message });
  }
};

// ===== UPDATE STEP STATUS (Simplified - No Edit Mode) =====
const updateJourneyStep = async (req, res) => {
  try {
    const { clientId, stepNumber } = req.params;
    const { 
      status,
      deadlineDate,
      notes,
      sendEmailNotification,
      contractAmount,
      downPaymentAmount,
      proposalAmount
    } = req.body;
    
    const journey = await Journey.findOne({ clientId })
      .populate('clientId', 'name email unitNumber floorPlan clientCode');
    
    if (!journey) {
      return res.status(404).json({ message: 'Journey not found' });
    }
    
    const stepIndex = journey.steps.findIndex(
      s => s.step === parseInt(stepNumber)
    );
    
    if (stepIndex === -1) {
      return res.status(404).json({ message: `Step ${stepNumber} not found` });
    }
    
    const step = journey.steps[stepIndex];
    
    // ===== SEQUENTIAL ENFORCEMENT =====
    if (status === 'completed') {
      // Check if previous step is completed (except for step 1)
      if (stepNumber > 1) {
        const previousStep = journey.steps.find(s => s.step === parseInt(stepNumber) - 1);
        if (!previousStep || previousStep.status !== 'completed') {
          return res.status(400).json({ 
            message: `Cannot complete step ${stepNumber}. Previous step must be completed first.`,
            currentStep: previousStep ? previousStep.step : 1,
            currentStepStatus: previousStep ? previousStep.status : 'not-started'
          });
        }
      }
      
      // Mark as completed
      step.status = 'completed';
      step.completedDate = new Date();
      
      // Auto-start next step if exists
      const nextStepIndex = stepIndex + 1;
      if (nextStepIndex < journey.steps.length) {
        const nextStep = journey.steps[nextStepIndex];
        if (nextStep.status === 'not-started') {
          nextStep.status = 'in-progress';
          nextStep.updatedAt = new Date();
        }
      }
      
    } else if (status === 'in-progress') {
      // Can only set in-progress if previous step is completed
      if (stepNumber > 1) {
        const previousStep = journey.steps.find(s => s.step === parseInt(stepNumber) - 1);
        if (!previousStep || previousStep.status !== 'completed') {
          return res.status(400).json({ 
            message: `Cannot start step ${stepNumber}. Previous step must be completed first.`
          });
        }
      }
      step.status = 'in-progress';
    }
    
    // Update deadline and notes
    if (deadlineDate !== undefined) {
      step.deadlineDate = deadlineDate || null;
    }
    
    if (notes !== undefined) {
      step.notes = notes;
    }
    
    step.updatedBy = req.user.id;
    step.updatedAt = new Date();
    
    // ===== AUTO-GENERATION LOGIC =====
    if (step.docAutoGenerated && status === 'completed') {
      try {
        // For steps that need document generation
        // You can add contract/proposal generation logic here
        console.log(`Step ${stepNumber} marked for document auto-generation`);
      } catch (genError) {
        console.error('Document generation error:', genError);
      }
    }
    
    await journey.save();
    await journey.populate('steps.updatedBy', 'name email');
    
    console.log(sendEmailNotification);
    console.log(step)

    // ===== EMAIL NOTIFICATION =====
    if (step.autoEmail && step.clientVisible) {
      console.log(sendEmailNotification)
      const templateFn = selectEmailTemplate(step);
      console.log("STEP NUMBER:", step.step, typeof step.step);


      if (!templateFn) {
        console.log(`⚠️ No email template mapped for step ${step.step}`);
      } else {
        const emailHTML = templateFn({
          clientName: journey.clientId.name,
          unitNumber: journey.clientId.unitNumber,
          amount: downPaymentAmount || proposalAmount || contractAmount,
        });

        await sendEmail({
          to: journey.clientId.email,
          subject: step.adminDescription,
          htmlContent: emailHTML   
        });
      }
    }
    
    res.json({
      message: 'Step updated successfully',
      step: journey.steps[stepIndex],
      nextStep: journey.steps[stepIndex + 1] || null
    });
  } catch (error) {
    console.error('Error updating step:', error);
    res.status(500).json({ message: 'Error updating step', error: error.message });
  }
};

// ===== MARK STEP AS COMPLETE (Quick action) =====
const completeJourneyStep = async (req, res) => {
  try {
    const { clientId, stepNumber } = req.params;
    const { notes } = req.body;
    
    // Just call updateJourneyStep with status 'completed'
    req.body.status = 'completed';
    if (notes) req.body.notes = notes;
    
    return updateJourneyStep(req, res);
  } catch (error) {
    console.error('Error completing step:', error);
    res.status(500).json({ message: 'Error completing step', error: error.message });
  }
};

// ===== GET ALL JOURNEYS (Admin only) =====
const getAllJourneys = async (req, res) => {
  try {
    const journeys = await Journey.find()
      .populate('clientId', 'name email clientCode unitNumber')
      .sort({ updatedAt: -1 });
    
    res.json({
      count: journeys.length,
      journeys
    });
  } catch (error) {
    console.error('Error fetching all journeys:', error);
    res.status(500).json({ message: 'Error fetching journeys', error: error.message });
  }
};

// ===== DELETE JOURNEY (Admin only) =====
const deleteJourney = async (req, res) => {
  try {
    const { clientId } = req.params;
    
    const journey = await Journey.findOneAndDelete({ clientId });
    
    if (!journey) {
      return res.status(404).json({ message: 'Journey not found' });
    }
    
    res.json({ message: 'Journey deleted successfully' });
  } catch (error) {
    console.error('Error deleting journey:', error);
    res.status(500).json({ message: 'Error deleting journey', error: error.message });
  }
};

// ===== GET STEP DOCUMENT =====
const getStepDocument = async (req, res) => {
  try {
    const { clientId, stepNumber, documentIndex } = req.params;
    
    const journey = await Journey.findOne({ clientId });
    if (!journey) {
      return res.status(404).json({ message: 'Journey not found' });
    }
    
    const step = journey.steps.find(s => s.step === parseInt(stepNumber));
    if (!step) {
      return res.status(404).json({ message: 'Step not found' });
    }
    
    const document = step.generatedDocuments[parseInt(documentIndex)];
    if (!document) {
      return res.status(404).json({ message: 'Document not found' });
    }
    
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${document.filename}"`);
    res.send(document.data);
    
  } catch (error) {
    console.error('Error fetching document:', error);
    res.status(500).json({ message: 'Error fetching document', error: error.message });
  }
};

// ===== GET PENDING CLIENT ACTIONS =====
const getPendingClientActions = async (req, res) => {
  try {
    const { clientId } = req.params;
    
    const journey = await Journey.findOne({ clientId })
      .populate('clientId', 'name email unitNumber');
    
    if (!journey) {
      return res.status(404).json({ message: 'Journey not found' });
    }
    
    const pendingActions = journey.getPendingClientActions();
    
    res.json({
      count: pendingActions.length,
      actions: pendingActions
    });
  } catch (error) {
    console.error('Error fetching pending actions:', error);
    res.status(500).json({ message: 'Error fetching pending actions', error: error.message });
  }
};

// ===== GET CLIENT VISIBLE STEPS ONLY =====
const getClientVisibleJourney = async (req, res) => {
  try {
    const { clientId } = req.params;
    
    const journey = await Journey.findOne({ clientId })
      .populate('clientId', 'name email unitNumber floorPlan clientCode');
    
    if (!journey) {
      return res.status(404).json({ message: 'Journey not found' });
    }
    
    // Filter to only client-visible steps
    const clientVisibleSteps = journey.steps.filter(s => s.clientVisible).map(step => ({
      step: step.step,
      stage: step.stage,
      title: step.clientDescription || step.adminDescription,
      description: step.notes,
      status: step.status,
      clientActionNeeded: step.clientActionNeeded,
      deadlineDate: step.deadlineDate,
      completedDate: step.completedDate,
      generatedDocuments: step.generatedDocuments
    }));
    
    // Get all stages (even if no visible steps)
    const allStages = [...new Set(journey.steps.map(s => s.stage))];
    
    res.json({
      clientId: journey.clientId,
      stages: allStages,
      steps: clientVisibleSteps,
      progressPercentage: journey.progressPercentage,
      currentStep: journey.currentStep
    });
  } catch (error) {
    console.error('Error fetching client journey:', error);
    res.status(500).json({ message: 'Error fetching client journey', error: error.message });
  }
};

// ===== GENERATE STEP PDF =====
const generateStepPdf = async (req, res) => {
  try {
    const { clientId, stepNumber } = req.params;

    const journey = await Journey.findOne({ clientId })
      .populate('clientId', 'name email clientCode unitNumber');

    if (!journey) {
      return res.status(404).json({ message: 'Journey not found' });
    }

    const step = journey.steps.find(s => s.step === parseInt(stepNumber));
    if (!step) {
      return res.status(404).json({ message: 'Step not found' });
    }

    if (!step.docAutoGenerated) {
      return res.status(400).json({ message: 'This step has no PDF generation feature' });
    }

    // ===== PDF TEMPLATE SELECTOR =====
    let pdfBuffer = null;
    if (step.adminDescription.includes("Contract")) {
      pdfBuffer = await generateContractPDF(journey.clientId, step);
    }
    else if (step.adminDescription.includes("Proposal")) {
      pdfBuffer = await generateProposalPDF(journey.clientId, step);
    }
    else if (step.step === 15) {
      pdfBuffer = await generateContractPDF(journey.clientId, step);
    }
    else {
      return res.status(400).json({ 
        message: 'No PDF generator assigned for this step'
      });
    }

    // ===== SAVE INTO MONGODB =====
    if (!step.generatedDocuments) step.generatedDocuments = [];

    const filename = `client_${clientId}_step_${stepNumber}_${Date.now()}.pdf`;

    step.generatedDocuments.push({
      filename,
      data: pdfBuffer
    });

    await journey.save();

    // ===== RETURN PDF FILE =====
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send(pdfBuffer);

  } catch (error) {
    console.error('PDF generation error:', error);
    res.status(500).json({ message: 'PDF generation error', error: error.message });
  }
};


module.exports = {
  getClientJourney,
  createClientJourney,
  updateJourneyStep,
  updateStepStatus: updateJourneyStep, // Alias for backward compatibility
  completeJourneyStep,
  completeStep: completeJourneyStep,   // Alias for backward compatibility
  getAllJourneys,
  deleteJourney,
  getStepDocument,
  getPendingClientActions,
  getClientVisibleJourney,
  generateStepPdf
};