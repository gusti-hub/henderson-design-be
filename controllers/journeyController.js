// controllers/journeyController.js - Updated with Invoice Integration
const Journey = require('../models/Journey');
const User = require('../models/User');
const sendEmail = require('../utils/sendEmail');
const { generateContractPDF, generateProposalPDF } = require('../utils/contractGenerator');
const { generateInvoiceDOCX, getInvoiceConfig } = require('../utils/invoiceGenerator');
const EMAIL_TEMPLATES = require('../utils/journeyEmailTemplates');
const selectEmailTemplate = require('../utils/journeyEmailMapper');

// Import all steps from data file
const JOURNEY_STEPS = require('../data/journeySteps');

// Steps that generate invoices
const INVOICE_STEPS = [15, 43, 58, 67];

// ===== GET CLIENT JOURNEY =====
const getClientJourney = async (req, res) => {
  try {
    const { clientId } = req.params;
    
    const client = await User.findById(clientId);
    if (!client) {
      return res.status(404).json({ message: 'Client not found' });
    }

    let journey = await Journey.findOne({ clientId })
      .populate('steps.updatedBy', 'name email')
      .populate('clientId', 'name email clientCode unitNumber floorPlan propertyType');
    
    if (!journey) {
      return res.status(404).json({ message: 'Journey not found for this client' });
    }
    
    res.json(journey);
  } catch (error) {
    console.error('Error fetching journey:', error);
    res.status(500).json({ message: 'Error fetching journey', error: error.message });
  }
};

// ===== CREATE CLIENT JOURNEY =====
const createClientJourney = async (req, res) => {
  try {
    const { clientId } = req.params;
    
    const existingJourney = await Journey.findOne({ clientId });
    if (existingJourney) {
      return res.status(400).json({ 
        message: 'Journey already exists for this client',
        journeyId: existingJourney._id
      });
    }
    
    const client = await User.findById(clientId);
    if (!client) {
      return res.status(404).json({ message: 'Client not found' });
    }

    // Create journey with all steps from data file
    const journey = await Journey.create({
      clientId,
      steps: JOURNEY_STEPS.map(stepData => ({
        step: stepData.step,
        stage: stepData.stage,
        owner: stepData.owner,
        adminDescription: stepData.adminDescription,
        clientDescription: stepData.clientDescription || '',
        clientVisible: stepData.clientVisible || false,
        autoEmail: stepData.autoEmail || false,
        docAutoGenerated: stepData.docAutoGenerated || false,
        clientActionNeeded: stepData.clientActionNeeded || false,
        notes: stepData.notes || '',
        status: stepData.step === 1 ? 'in-progress' : 'not-started',
        deadlineDate: null,
        completedDate: null,
        updatedBy: req.user.id,
        updatedAt: new Date()
      }))
    });
    
    await journey.populate('clientId', 'name email clientCode unitNumber');
    
    res.status(201).json({
      message: `Journey created successfully with ${JOURNEY_STEPS.length} steps`,
      journey
    });
  } catch (error) {
    console.error('Error creating journey:', error);
    res.status(500).json({ message: 'Error creating journey', error: error.message });
  }
};

// ===== UPDATE STEP STATUS WITH INVOICE GENERATION =====
const updateJourneyStep = async (req, res) => {
  try {
    const { clientId, stepNumber } = req.params;
    const { 
      status,
      deadlineDate,
      notes,
      sendEmailNotification,
      contractAmount,
      downPaymentAmount,
      proposalAmount,
      autoGenerateInvoice = true // New parameter
    } = req.body;
    
    const journey = await Journey.findOne({ clientId })
      .populate('clientId', 'name email unitNumber floorPlan clientCode collection bedroomCount paymentInfo');
    
    if (!journey) {
      return res.status(404).json({ message: 'Journey not found' });
    }
    
    const stepIndex = journey.steps.findIndex(
      s => s.step === parseInt(stepNumber)
    );
    
    if (stepIndex === -1) {
      return res.status(404).json({ message: `Step ${stepNumber} not found` });
    }
    
    const step = journey.steps[stepIndex];
    const stepNum = parseInt(stepNumber);
    
    // ===== SEQUENTIAL ENFORCEMENT =====
    if (status === 'completed') {
      // Check if previous step is completed
      if (stepNum > 1) {
        const previousStep = journey.steps.find(s => s.step === stepNum - 1);
        if (!previousStep || previousStep.status !== 'completed') {
          return res.status(400).json({ 
            message: `Cannot complete step ${stepNum}. Previous step must be completed first.`
          });
        }
      }
      
      step.status = 'completed';
      step.completedDate = new Date();
      
      // Auto-start next step
      const nextStepIndex = stepIndex + 1;
      if (nextStepIndex < journey.steps.length) {
        const nextStep = journey.steps[nextStepIndex];
        if (nextStep.status === 'not-started') {
          nextStep.status = 'in-progress';
          nextStep.updatedAt = new Date();
        }
      }
      
    } else if (status === 'in-progress') {
      if (stepNum > 1) {
        const previousStep = journey.steps.find(s => s.step === stepNum - 1);
        if (!previousStep || previousStep.status !== 'completed') {
          return res.status(400).json({ 
            message: `Cannot start step ${stepNum}. Previous step must be completed first.`
          });
        }
      }
      step.status = 'in-progress';
    }
    
    // Update deadline and notes
    if (deadlineDate !== undefined) {
      step.deadlineDate = deadlineDate || null;
    }
    
    if (notes !== undefined) {
      step.notes = notes;
    }
    
    step.updatedBy = req.user.id;
    step.updatedAt = new Date();
    
    // ===== AUTO-GENERATE INVOICE FOR STEPS 15, 43, 58, 67 =====
    let invoiceGenerated = false;
    let invoiceData = null;
    
    if (INVOICE_STEPS.includes(stepNum) && status === 'completed' && autoGenerateInvoice) {
      try {
        const client = journey.clientId;
        
        // Check if invoice already exists
        const existingInvoice = client.invoices.find(inv => inv.stepNumber === stepNum);
        
        if (!existingInvoice) {
          // Generate invoice number
          const invoiceNumber = client.generateInvoiceNumber();
          
          // Get invoice config
          const config = getInvoiceConfig(stepNum);
          
          // Calculate amount
          const totalAmount = client.paymentInfo?.totalAmount || 0;
          const invoiceAmount = Math.round(totalAmount * (config.percentage / 100));
          
          // Generate DOCX
          const docxBuffer = await generateInvoiceDOCX(client, stepNum, invoiceNumber);
          
          // Save invoice to user
          const invoice = {
            invoiceNumber,
            stepNumber: stepNum,
            invoiceType: config.type,
            amount: invoiceAmount,
            percentage: config.percentage,
            description: config.description(
              client.collection || 'Collection',
              client.bedroomCount ? `${client.bedroomCount} Bedroom` : '1 Bedroom'
            ),
            dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
            documentPath: `/invoices/${client.clientCode}/${invoiceNumber}.docx`,
            documentBuffer: docxBuffer,
            generatedAt: new Date(),
            quickbooksSyncStatus: 'not-synced'
          };
          
          client.invoices.push(invoice);
          await client.save();
          
          // Also save to journey step
          if (!step.generatedDocuments) {
            step.generatedDocuments = [];
          }
          step.generatedDocuments.push({
            type: 'invoice',
            filename: `${invoiceNumber}.docx`,
            data: docxBuffer,
            generatedAt: new Date()
          });
          
          invoiceGenerated = true;
          invoiceData = {
            invoiceNumber: invoice.invoiceNumber,
            amount: invoice.amount,
            percentage: invoice.percentage,
            dueDate: invoice.dueDate
          };
          
          console.log(`âœ“ Invoice ${invoiceNumber} generated for step ${stepNum}`);
        }
      } catch (invoiceError) {
        console.error('Invoice generation error:', invoiceError);
        // Don't fail the step update, just log the error
      }
    }
    
    // ===== OTHER DOCUMENT AUTO-GENERATION =====
    if (step.docAutoGenerated && status === 'completed' && !INVOICE_STEPS.includes(stepNum)) {
      try {
        console.log(`Step ${stepNum} marked for document auto-generation`);
        // Handle other document types (contracts, proposals, etc.)
      } catch (genError) {
        console.error('Document generation error:', genError);
      }
    }
    
    await journey.save();
    await journey.populate('steps.updatedBy', 'name email');
    
    // ===== EMAIL NOTIFICATION =====
    if (step.autoEmail && step.clientVisible) {
      const templateFn = selectEmailTemplate(step);
      
      if (templateFn) {
        const emailHTML = templateFn({
          clientName: journey.clientId.name,
          unitNumber: journey.clientId.unitNumber,
          amount: downPaymentAmount || proposalAmount || contractAmount || invoiceData?.amount,
          invoiceNumber: invoiceData?.invoiceNumber
        });

        await sendEmail({
          to: journey.clientId.email,
          subject: step.adminDescription,
          htmlContent: emailHTML   
        });
      }
    }
    
    res.json({
      message: 'Step updated successfully',
      step: journey.steps[stepIndex],
      nextStep: journey.steps[stepIndex + 1] || null,
      invoiceGenerated,
      invoice: invoiceData
    });
  } catch (error) {
    console.error('Error updating step:', error);
    res.status(500).json({ message: 'Error updating step', error: error.message });
  }
};

// ===== MARK STEP AS COMPLETE (Quick action) =====
const completeJourneyStep = async (req, res) => {
  try {
    const { clientId, stepNumber } = req.params;
    const { notes } = req.body;
    
    req.body.status = 'completed';
    if (notes) req.body.notes = notes;
    
    return updateJourneyStep(req, res);
  } catch (error) {
    console.error('Error completing step:', error);
    res.status(500).json({ message: 'Error completing step', error: error.message });
  }
};

// ===== GET ALL JOURNEYS (Admin only) =====
const getAllJourneys = async (req, res) => {
  try {
    const journeys = await Journey.find()
      .populate('clientId', 'name email clientCode unitNumber')
      .sort({ updatedAt: -1 });
    
    res.json({
      count: journeys.length,
      journeys
    });
  } catch (error) {
    console.error('Error fetching all journeys:', error);
    res.status(500).json({ message: 'Error fetching journeys', error: error.message });
  }
};

// ===== DELETE JOURNEY (Admin only) =====
const deleteJourney = async (req, res) => {
  try {
    const { clientId } = req.params;
    
    const journey = await Journey.findOneAndDelete({ clientId });
    
    if (!journey) {
      return res.status(404).json({ message: 'Journey not found' });
    }
    
    res.json({ message: 'Journey deleted successfully' });
  } catch (error) {
    console.error('Error deleting journey:', error);
    res.status(500).json({ message: 'Error deleting journey', error: error.message });
  }
};

// ===== GET STEP DOCUMENT =====
const getStepDocument = async (req, res) => {
  try {
    const { clientId, stepNumber, documentIndex } = req.params;
    
    const journey = await Journey.findOne({ clientId });
    if (!journey) {
      return res.status(404).json({ message: 'Journey not found' });
    }
    
    const step = journey.steps.find(s => s.step === parseInt(stepNumber));
    if (!step) {
      return res.status(404).json({ message: 'Step not found' });
    }
    
    const document = step.generatedDocuments[parseInt(documentIndex)];
    if (!document) {
      return res.status(404).json({ message: 'Document not found' });
    }
    
    // Determine content type based on document type
    let contentType = 'application/octet-stream';
    if (document.filename.endsWith('.pdf')) {
      contentType = 'application/pdf';
    } else if (document.filename.endsWith('.docx')) {
      contentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
    }
    
    res.setHeader('Content-Type', contentType);
    res.setHeader('Content-Disposition', `attachment; filename="${document.filename}"`);
    res.send(document.data);
    
  } catch (error) {
    console.error('Error fetching document:', error);
    res.status(500).json({ message: 'Error fetching document', error: error.message });
  }
};

// ===== GET PENDING CLIENT ACTIONS =====
const getPendingClientActions = async (req, res) => {
  try {
    const { clientId } = req.params;
    
    const journey = await Journey.findOne({ clientId })
      .populate('clientId', 'name email unitNumber');
    
    if (!journey) {
      return res.status(404).json({ message: 'Journey not found' });
    }
    
    const pendingActions = journey.getPendingClientActions();
    
    res.json({
      count: pendingActions.length,
      actions: pendingActions
    });
  } catch (error) {
    console.error('Error fetching pending actions:', error);
    res.status(500).json({ message: 'Error fetching pending actions', error: error.message });
  }
};

// ===== GET CLIENT VISIBLE STEPS ONLY =====
const getClientVisibleJourney = async (req, res) => {
  try {
    const { clientId } = req.params;
    
    const journey = await Journey.findOne({ clientId })
      .populate('clientId', 'name email unitNumber floorPlan clientCode');
    
    if (!journey) {
      return res.status(404).json({ message: 'Journey not found' });
    }
    
    const clientVisibleSteps = journey.steps.filter(s => s.clientVisible).map(step => ({
      step: step.step,
      stage: step.stage,
      title: step.clientDescription || step.adminDescription,
      description: step.notes,
      status: step.status,
      clientActionNeeded: step.clientActionNeeded,
      deadlineDate: step.deadlineDate,
      completedDate: step.completedDate,
      generatedDocuments: step.generatedDocuments
    }));
    
    const allStages = [...new Set(journey.steps.map(s => s.stage))];
    
    res.json({
      clientId: journey.clientId,
      stages: allStages,
      steps: clientVisibleSteps,
      progressPercentage: journey.progressPercentage,
      currentStep: journey.currentStep
    });
  } catch (error) {
    console.error('Error fetching client journey:', error);
    res.status(500).json({ message: 'Error fetching client journey', error: error.message });
  }
};

// ===== GENERATE STEP PDF/DOCX =====
const generateStepPdf = async (req, res) => {
  try {
    const { clientId, stepNumber } = req.params;
    const { bypassSequentialCheck } = req.query; // NEW: Query parameter to bypass

    const journey = await Journey.findOne({ clientId })
      .populate('clientId', 'name email clientCode unitNumber collection bedroomCount paymentInfo invoices');

    if (!journey) {
      return res.status(404).json({ message: 'Journey not found' });
    }

    const step = journey.steps.find(s => s.step === parseInt(stepNumber));
    if (!step) {
      return res.status(404).json({ message: 'Step not found' });
    }

    if (!step.docAutoGenerated) {
      return res.status(400).json({ message: 'This step has no document generation feature' });
    }

    const stepNum = parseInt(stepNumber);
    let docxBuffer = null;
    let filename = '';

    // Check if it's an invoice step
    if (INVOICE_STEPS.includes(stepNum)) {
      const client = journey.clientId;
      
      // Initialize invoices array if not exists
      if (!client.invoices) {
        client.invoices = [];
      }
      
      // Check if invoice already exists
      let invoice = client.invoices.find(inv => inv.stepNumber === stepNum);
      
      if (!invoice) {
        // Return existing invoice
        docxBuffer = invoice.documentBuffer;
        filename = `${invoice.invoiceNumber}.docx`;
      } else {
        // Generate new invoice
        const invoiceNumber = client.generateInvoiceNumber();
        docxBuffer = await generateInvoiceDOCX(client, stepNum, invoiceNumber);
        filename = `${invoiceNumber}.docx`;
        
        // Save to database
        const config = getInvoiceConfig(stepNum);
        const totalAmount = client.paymentInfo?.totalAmount || 0;
        const invoiceAmount = Math.round(totalAmount * (config.percentage / 100));
        
        invoice = {
          invoiceNumber,
          stepNumber: stepNum,
          invoiceType: config.type,
          amount: invoiceAmount,
          percentage: config.percentage,
          description: config.description(
            client.collection || 'Collection',
            client.bedroomCount ? `${client.bedroomCount} Bedroom` : '1 Bedroom'
          ),
          dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
          documentPath: `/invoices/${client.clientCode}/${invoiceNumber}.docx`,
          documentBuffer: docxBuffer,
          generatedAt: new Date(),
          quickbooksSyncStatus: 'not-synced'
        };
        
        client.invoices.push(invoice);
        await client.save();
      }
    } else {
      // Handle other document types
      if (step.adminDescription.includes("Contract")) {
        docxBuffer = await generateContractPDF(journey.clientId, step);
        filename = `Contract_Step_${stepNum}_${Date.now()}.docx`;
      } else if (step.adminDescription.includes("Proposal")) {
        docxBuffer = await generateProposalPDF(journey.clientId, step);
        filename = `Proposal_Step_${stepNum}_${Date.now()}.docx`;
      } else {
        return res.status(400).json({ 
          message: 'No document generator assigned for this step'
        });
      }
    }

    // Save into journey step
    if (!step.generatedDocuments) step.generatedDocuments = [];
    
    const existingDoc = step.generatedDocuments.find(d => d.filename === filename);
    if (!existingDoc) {
      step.generatedDocuments.push({
        filename,
        data: docxBuffer
      });
      await journey.save();
    }

    // Return file
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send(docxBuffer);

  } catch (error) {
    console.error('Document generation error:', error);
    res.status(500).json({ message: 'Document generation error', error: error.message });
  }
};

module.exports = {
  getClientJourney,
  createClientJourney,
  updateJourneyStep,
  updateStepStatus: updateJourneyStep,
  completeJourneyStep,
  completeStep: completeJourneyStep,
  getAllJourneys,
  deleteJourney,
  getStepDocument,
  getPendingClientActions,
  getClientVisibleJourney,
  generateStepPdf
};